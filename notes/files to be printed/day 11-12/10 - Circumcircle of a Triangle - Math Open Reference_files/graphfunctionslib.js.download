
function SliderRangeDlg()
{  //build the dialog html in the host page
   var html =
	 "<div id='rangedlg' style='position:absolute; left:100px; top:50px; visibility:hidden; background:#ece9e8; width: 300px; height:185px; border:2px outset gray; z-index:1000;'>"
	+"<div id='dlgHead' style='background:#7b97e0; color:white; font-family:sans-serif; font-size:14px ; height:21px; padding:4px 0 0 20px'></div>"

	+"<table style='margin-top:20px;margin-bottom:15px'  border=0 align=center cellspacing=4>"
	+"<tr><td>Upper limit</td><td><INPUT id='upper'></td></tr>"
	+"<tr><td>Lower limit</td><td><INPUT id='lower' ></td></tr>"
	+"<tr style='color:red; text-align:center;height:24px'><td id='errmsg' colspan='2'></td></tr>"
	+"</table>"

	+"<INPUT   style='margin-left:90px; margin-right:20px' id='ok' TYPE='button' value='OK' onclick='dlgok()' >"
	+"<INPUT  TYPE='button'  value='Cancel' onclick='closeDlg()'>"
	+"</div>";

    var bod = document.getElementsByTagName('body')[0];
	bod.innerHTML += html;


    this.show = function(slider)
     { rangeSlider = slider;
       document.getElementById('rangedlg').style.visibility = "visible";

       //insert current values into fields
       document.getElementById('dlgHead').innerHTML = "Set range for slider "+slider.labl.text;
       document.getElementById('upper').value = slider.high;
       document.getElementById('lower').value = slider.low;
     };

};

function closeDlg()
{ document.getElementById('rangedlg').style.visibility = "hidden";
};


function dlgok()
{ var upperLim = document.getElementById('upper').value;
  var lowerLim = document.getElementById('lower').value;
  document.getElementById('errmsg').innerHTML ="";

  if(!goodInput(upperLim)) return;
  if(!goodInput(lowerLim)) return;

  var upperNum = new Number(upperLim);
  var lowerNum = new Number(lowerLim);

  if(upperNum < lowerNum)
	{ document.getElementById('errmsg').innerHTML = "Lower limit must be less than upper";
      return;
	}

  if(upperNum < lowerNum)
	{ document.getElementById('errmsg').innerHTML = "Lower limit must be less than upper";
      return;
	}

  if( !inRange(upperNum) || !inRange(lowerNum) )
	{ document.getElementById('errmsg').innerHTML = "Limits must be between +99 and -99";
      return;
	}


  //inputs all look good, stuff them back into the slider.  Show() saved the pointer to the slider.
  rangeSlider.setHigh(upperNum);
  rangeSlider.setLow(lowerNum);

  //make the slider thumb, value  and readout adjust to the new limits
  rangeSlider.setValue(rangeSlider.getValue());
  update();

  closeDlg();

};


function goodInput(val)
{ var num = new Number(val);
  if(val.trim().length==0 || isNaN(val) )
    { document.getElementById('errmsg').innerHTML = "Both limits must be valid numbers";
      return false;
    }
  else
    return true;
};


function inRange(v)
{ return (v<=99 && v>-99);
};

















function Axes(wid, ht)  //Constructor
{   this.wid = wid;
	this.ht  = ht;

	this.xMin;
	this.xMax;
	this.yMin;
	this.yMax;

	this.wid;
	this.ht;

	this.gridColor = 0xbbbbaa;
	this.gridAlpha = 1;

	this.axisColor  = 0x56789a;
	this.arrowColor = 0x888888;
	this.labelColor = 0x5555aa;

    this.labels = new Sprite();  //labels are in own sprite for easy delete of children
    addChild(this.labels);


    this.clear = function()
    {  this.labels.removeChild("all");
    };



	this.draw = function(xMin, xMax, yMin, yMax, gridVisible)
	{ this.xMin = xMin;
	  this.xMax = xMax;
	  this.yMin = yMin;
	  this.yMax = yMax;

	  //clear old labels
	  this.clear();

	  if(gridVisible)
	  	{ this.drawXGrid();
	      this.drawYGrid();
		}
	  this.drawAxes();
	};




	this.drawXGrid = function()
	{
       var xPeriod = this.gridDelta(this.xMax , this.xMin);
	   var firstGridLine = (Math.round(this.xMin/xPeriod)+1)*xPeriod;
	   var vPos = this.ht-20;
	   var labelVal;
	   var CENTER = 3;

	   //If x axis is on chart put labels below it, else at bottom
	   with(this)
			{  if(sign(yMin) != sign(yMax))
                 vPos = ytoPix(0)+graphTop+3;

			   for(var i=firstGridLine; i<xMax; i+=xPeriod)
				  {   i = roundtoN(i,3);  //because flash cannot add accurately!
					  with(graphics)
						{  lineStyle(1,gridColor, gridAlpha);
						   moveTo(graphLeft+xtoPix(i), graphTop);
						   lineTo(graphLeft+xtoPix(i), graphTop+graphHeight);
						}
					  labelVal = roundtoN(i,2);
					  if(labelVal != 0)
						{ makeLabel(xtoPix(i)+graphLeft , vPos, labelVal, CENTER);
						}
				  }
			}
	};



	this.drawYGrid = function()
	{ with (this)
		{ var LEFT = 1;
		  var RIGHT = 2;
		  var CENTER = 3;

		  var yPeriod = this.gridDelta(yMax , yMin);
		  var firstGridLine = (Math.round(yMin/yPeriod)+1)*yPeriod;
		  var hPos, align;
		  var labelVal;

		  //determine position of labels
		  if(xtoPix(0) <0) //y axis if off left edge, label left edge of chart
			{ hPos = 3;
			  align=LEFT;
			}
		  else if (xtoPix(0)> wid)  //y axis if off right edge, label right edge of chart
			{ hPos = wid;
			  align=RIGHT;
			}
		  else if(xtoPix(0)> wid-20) //y axis is on the right but on chart, so labels go on its left
			{  hPos = xtoPix(0)-3;
			   align = RIGHT;
			}
		  else if(xtoPix(0)==0) // axis is on left edge, labels on left of chart
			{  hPos= 3 ;
			   align=LEFT;
			}
		  else // axis on chart, labels right of axis
			{ hPos = xtoPix(0)+graphLeft+4;
			  align = LEFT;
			}

		  for(var i=firstGridLine; i<yMax; i+=yPeriod)
			  {   i = roundtoN(i,3);    //because cannot add accurately!
				  with(graphics)
					{  lineStyle(1,gridColor, gridAlpha);
					   moveTo(graphLeft, ytoPix(i)+graphTop );
					   lineTo(graphLeft+graphWidth, ytoPix(i)+graphTop);
					}
				  labelVal = roundtoN(i,2);
				  if(labelVal != 0)
					{ makeLabel(hPos, ytoPix(i)+graphTop-9, labelVal, align);
					}
			  }
        } //with
	};



	this.makeLabel = function(xLoc,  yLoc, txt, align)
	{ var LEFT = 1;
	  var RIGHT = 2;
	  var CENTER = 3;

      var label = new TextObj(0,0,txt,0x666666);
	  with(label)
		{  var width = getWidth();
           switch(align)
				{ case LEFT:   x = xLoc;           break;
				  case RIGHT:  x = xLoc - width;   break;
				  case CENTER: x = xLoc - width/2; break;
				}
		   y  = yLoc;
		}
	   this.labels.addChild(label);
	   return label;
	};



	this.gridDelta = function(vMin, vMax)
	// A heuristic that determines the delta increment for each grid line
	// vMin and vMax are the axis range limits
	{
		var decade = 0;
		var period;

		//force range to be in (0..10)
		var range = Math.abs(vMax-vMin);   // find the range
		while(range>10) { range /= 10; decade++; }
		while(range<1 ) { range *= 10; decade--; }

		period = Math.ceil(range)/10;
		return period*Math.pow(10,decade);
	};




	this.drawAxes = function()
	{	with(this)
			{ var y0 = ytoPix(0)+graphTop;
			  var x0 = Math.round( xtoPix(0) ) + graphLeft;
			  if(x0==wid) x0=wid-2;
			  if(x0==0)  x0=2;
			  with(graphics)
				 { //x axis
				   lineStyle(1.4, axisColor);
				   moveTo(graphLeft, y0);
				   lineTo(graphLeft+graphWidth,y0);

				   //y axis
				   lineStyle(1.4, axisColor);
				   moveTo(x0,graphTop);
				   lineTo(x0,graphTop+graphHeight);
				 }
            } //this
   };


	this.xtoPix = function(mathx)
	{ with(this)
		{ return ( wid*(mathx - xMin)/(xMax - xMin) );
        }
	};


	this.ytoPix = function(mathy)
	{ with(this)
		{ return ( ht*(yMax - mathy)/(yMax - yMin) );
        }
	};


    this.sign = function(x)
	{ var POS = 1;
	  var NEG = -1;
      if(x<0)
		return NEG;
	  else
	  	return POS;
	};



}; //class













// FunctionField

//  A collection of UI objects tthat corresponds to the controls for each function



function FunctionField (labl,
						xLoc, yLoc,
						color, fillColor,
						readoutY, callback)
{   this.type = "FunctionField";
    this.color;
	this.fillColor;
	this.lab;
	this.relop;
	this.fn;
	this.compiledFn = null;
	this.display;
	this.inpFmt;
	this.labl;
	this.csrDot;

    this.x         = 0;
	this.y         = 0;
	this.color     = color;
	this.fillColor = fillColor;
	this.labl      = labl;

	this.defaultFillColor = fillColor;

    this.lab = new TextObj(xLoc, yLoc, labl, color, false, false, 14 );   //label eg "f(x)"

	this.relop = new ComboBox(callback);   // relop selector
	with(this.relop)
		{ x      = xLoc+29;
		  y      = yLoc;
		  height = 21;
		  width  = 44;
		  addItem({label:"=" ,  data:"eq"} );  //0
		  addItem({label:"<" ,  data:"lt"} );  //1
		  addItem({label:"<=" , data:"le"} );  //2
		  addItem({label:">" ,  data:"gt"} );  //3
		  addItem({label:">=" , data:"ge"} );  //4
		  selectedIndex = 0;  //defaults to =
          update();
		};


	this.fn = new TextField();
	with (this.fn)
	 { x      = xLoc+75;
	   y      = yLoc+1;
	   width  = 310;
	   textColor = color;
	 };

    this.display = new Checkbox(this.fn.x + this.fn.width+6,  yLoc+3, "show", true, true, callback);


	//assemble display list
	addChild(this.lab);
	addChild(this.display);
    addChild(this.relop);




   this.update = function()
     { this.fn.update();
       this.relop.update();
       this.display.update();
     };

   this.reset = function() {};

   this.paint = function() {};

   this.setMono = function(mono)
	{ if(mono)
		this.fillColor = 0x000000;
	  else
		this.fillColor = this.defaultFillColor;
	};


   this.setCsrDot = function(xLoc, yLoc, vis)
	{ with(csrDot)
		{ x = xLoc;
		  y = yLoc;
		  visible = vis;
		}
	};

}; //class












function GraphCursor(hgt, wid, xMin, xMax, yMin, yMax,f1, f2, f3, evalFn)  //Constructor
{   this.type = "GraphCursor";
	this.x     = 0;
	this.y     = 0;
	this.xMin  = xMin;
	this.xMax  = xMax;
	this.yMin  = yMin;
	this.yMax  = yMax;
	this.f1    = f1;
	this.f2    = f2;
	this.f3    = f3;
	this.evalFn = evalFn;
	this.color  = 0x0048d8;
    this.hairlineX;  //px location of hairline
    this.visible = true;
    this.built = false;

	this.xMin, this.xMax, this.yMin, this.yMax;

	this.f1; this.f2; this.f3;
	this.hintPt = new GeomPoint(0,60);
	this.hint = new Hint(this.hintPt, Hint.ABOVERT, "Drag cursor line");
	this.xLabel;
    this.xValueBox;
	this.firstTime = true;  //controls hint displayed only first time

    this.draggingLine = false;
    this.fingerOffset = 0;


	//X value label and textbox
	this.xLabel = new TextObj(40,26, "x =", 0x666666, true, true, 14);
	this.xValueBox  = new TextField();
	with(this.xValueBox)
		{ x               = 68;
		  y               = 24;
		  width           = 50;
		  height          = 17;
		  border          = true;
		  borderColor     = 0x888888;
		  background      = true;
		  backgroundColor = 0xffffff;
		  textColor       = 0x000000;
		};


    //make a canvas element for the output.
    //This floats over the main applet so only this part needs to be redrawn as the sliders move.
    this.can = document.createElement('canvas');
	with( this.can)
		{  with(style)
	         { position = "absolute";
               top =  (graphTop*bScale)+"px";
               left = (graphLeft*bScale)+"px";
            }
          width = graphWidth*bScale;
		  height = graphHeight*bScale;
		}

    //attach it to host window
	document.body.appendChild(this.can);
    this.context = this.can.getContext('2d');
    this.context.scale(bScale, bScale);


this.update = function()
{  this.paint();
};


this.reset = function() {};




this.paint = function()
{ if(!this.built)
     this.build();

  //control visibility.  This all depends on the fact that the components are after this in the displaylist
  this.xValueBox.visible = this.visible;
  this.xLabel.visible    = this.visible;

  this.context.clearRect(0,0,graphWidth, graphHeight);

  if(this.visible)
     with(this)
		{ with(context)  //draw the hairline
			{ beginPath();
			  moveTo(this.hairlineX, 0);
			  lineTo(this.hairlineX, graphHeight);
			  strokeStyle =  "red";
			  stroke();
			}

		  setReadout(f1, 45, 0x0000ff); //set values into the readouts
		  setReadout(f2, 63, 0x000000);
		  setReadout(f3, 81, 0xff0000);
		}
};




this.build = function()
// we need to ensure that all the child components are after 'this' in the displayList.
// So we cannot call the addchild()s until 'this' is built and added to the dipslayList itself.
// So they cannot be in the constructor.  That would be too soon.
{
	//addChild(this.hint);
	addChild(this.xLabel);
	addChild(this.xValueBox);

    this.can.onmousemove = this.mouseMove;
    this.can.onmousedown = this.mouseDown;
    this.can.onmouseup   = this.mouseUp;

    this.can.ontouchstart  = this.touchStart;
    this.can.ontouchmove   = this.touchMove;
    this.can.ontouchend    = this.touchEnd;

    this.built = true;

};


this.touchStart = function(e)
{  if (!e) var e = event;
   e.preventDefault();
   if(graphCsr.visible)
	 { var x =  e.pageX/bScale - graphLeft;
       graphCsr.draggingLine = true;
       graphCsr.fingerOffset = x - 	graphCsr.hairlineX;  //+ve if finger right of hairline
     }
};



this.touchMove = function(e)
{  if(graphCsr.visible && graphCsr.draggingLine)
		{ if (!e) var e = event;
		  e.preventDefault();
		  var x =  e.pageX/bScale - graphLeft;
		  var newHairlineX =  x -graphCsr.fingerOffset;
		  graphCsr.hairlineX = Math.round(newHairlineX)+0.5; //keep on half px boundary to stay thin
		  graphCsr.setReadoutsFromHairline();
		  graphCsr.paint();
	   }
};


this.touchEnd = function(e)
{ graphCsr.draggingLine = false;
  graphCsr.fingerOffset = 0
};



this.mouseMove = function(e)
{   if(graphCsr.visible)
		 {  if (!e) var e = event;
			var x =  e.pageX/bScale - graphLeft;

            if(graphCsr.draggingLine)
				{ graphCsr.hairlineX = Math.round(x)+0.5; //keep on half px boundary to stay thin
                  graphCsr.setReadoutsFromHairline();
                  graphCsr.paint();
				}

			var inRange = (Math.abs(x-graphCsr.hairlineX)<3);
			graphCsr.can.style.cursor = inRange? "pointer" : "auto";
         }
};


this.mouseDown = function(e)
{ if(graphCsr.visible)
	{  if (!e) var e = event;
	   var x =  e.pageX/bScale - graphLeft;
       graphCsr.hint.visible = false;

	   var inRange = (Math.abs(x-graphCsr.hairlineX)<3);
       if(inRange)
		{ graphCsr.draggingLine = true;
        }
    }
};


this.mouseUp = function(e)
{ graphCsr.draggingLine = false;
};



this.setReadoutsFromHairline = function()
{  var mathX = this.xMin.val + ((this.hairlineX/graphWidth)*(this.xMax.val - this.xMin.val));
   this.xValueBox.setValue(roundtoN(mathX, 4));
};


this.getXVal = function()
{ return this.xValueBox.getValue();
};


this.setReadout = function(func, yLoc, color)
//Sets the readout from the function and csr value
{
   if(func.compiledFn != null && func.display.selected)
		{ var xVal = this.xValueBox.getValue();
		  var yVal = this.evalFn(func, xVal);
          var readoutText;

		   if( isNaN(yVal) )
			  { readoutText = func.labl + " = undefined";
			  }
		   else
			  { yVal = roundtoN(yVal, 4);
				readoutText = func.labl + " = "+yVal;
			  }

           //display the readout
           this.context.fillStyle = toStr(color, 0.5);
           this.context.font = "italic bold 12px sans-serif";
           this.context.fillText(readoutText, 3, yLoc);

		   //do the dot
		   var dotX = this.xtoPix(xVal);
		   var dotY = this.ytoPix(yVal);
           with(this.context)
			{ beginPath();
			  arc(dotX, dotY, 2, 0 ,Math.PI*2, true); //black dot
			  fill();
			}
		}
};




this.setCsrXval = function(val)
// sets csr to a given x value in math units
// Sets the val into input textbox then makes all else match it.
// if val is null, set it to zero.  Used on init mostly
{  if(val==null)
	  this.xValueBox.setValue(0);
   else
	  this.xValueBox.setValue( roundtoN(val, 4) );
};




this.setFromInputBox = function()
// The graph key or Enter key was pressed .  The user may have entered a manual value into
// the input box. Sets hairline xLoc.  Later, paint() will draw it if rqd
{   var input = this.xValueBox.getValue();
    var range = this.xMax.val-this.xMin.val;
	var csrFrac = (input-this.xMin.val)/range;  // eg 0.65 of total x axis from the left
	this.hairlineX = graphWidth*csrFrac;
};




this.xtoPix = function(mathx)
{  var res = graphWidth*(mathx - this.xMin.val)/(this.xMax.val - this.xMin.val);
   return res;
};

this.ytoPix = function(mathy)
{  var res = graphHeight*(this.yMax.val - mathy)/(this.yMax.val - this.yMin.val) ;
   return res;
};


}; //class









/*
	Consists of two functions.

    doCompile(inputstring, varArray)
		This takes an expression and returns a CompiledObject that can be passed to doEval()
        varArray:  An array of strings holding the variable names used in the expression EG ["x","a","b"];
		Returns: A CompiledObject

	doEval(compiledExpression, aVarVals)
		This executes the compiled function built by  doCompile()
        aVarVals:  An array of values for the variables.  MUST be in the same order as the variable names given to doCompile();
        Returns: The computed value of the expression.  If an error (eg div by zero)  NaN is returned.
*/


  var p_singleParamFnNames = ["sin","cos","tan","log","ln","sqrt", "exp", "abs", "acos","asin", "atan" ,"ceil", "floor", "round","sec","csc","cot"];
  var p_twoParamFnNames    = ["max","min","plus","minus","mul","div","pow"];

  var p_iserror = 0;
  var p_errorMes = "";

  var p_tokenvalue;
  var p_tokenType;
  var p_tokenLength;

  var p_digits    = "0123456789.";
  var p_letters   = "abcdefghijklmnopqrstuwvxzy";
  var p_operators = "^*+-/(),";

  var p_varNames;



function doCompile(inputstring, varArray)
{	var stepString;
	var conString;
	var fstack = [];

    // get the variable names
    p_varNames = [];
    for(var i=0 ; i<varArray.length ; i++)
	  { p_varNames[i]=varArray[i].toLowerCase();
      }

	p_iserror = 0;
	p_errorMes = "";

	stepString = whiteSpaces(inputstring); //remove spaces
	if(stepString=="")
		return errorObject("", 0);  //empty input.  return an empty compiled obj , no error

	checkLegal(stepString);  //check all input chars are legal
	if(p_iserror==1) return errorObject(p_errorMes, 1);

	checkPars(stepString);
	if(p_iserror==1) return errorObject(p_errorMes, 1);  //problem with parentheses

	checkToks(stepString);                           //tokenize and check for errs
	if(p_iserror==1) return errorObject(p_errorMes, 1);

	conString=conOper(conOper(conOper(conOper(conUnary(conCaret(stepString)),"/"),"*"),"-"),"+");
	if(p_iserror==1) return errorObject(p_errorMes, 1);

	fstack = makeStack(conString);
	if(p_iserror==1) return errorObject(p_errorMes, 1);

	//good compile, return it
	var coCompObj = new CompiledObject();
	with( coCompObj)
		{ polishArray=fstack;
	      p_errorMes="";
          errorStatus=0;
		}
	return coCompObj;

};



function isTokenF1(chars)
{  for(var i=0; i< p_singleParamFnNames.length; i++)
     { if(chars == p_singleParamFnNames[i]) return true;
     }
	return false;
};


function isTokenF2(chars)
{ for(var i=0; i< p_twoParamFnNames.length; i++)
    { if(chars == p_twoParamFnNames[i]) return true;
	}
  return false;
};


function isVariable(chars)
{
  for(var i=0; i< p_varNames.length; i++)
	{  if(chars == p_varNames[i]) return true;
	}
  return false;
};


function isLetter(char)
{ return p_letters.indexOf(char) >= 0 ;
};


function isOperator(char)
{ return p_operators.indexOf(char) >= 0 ;
};


function isNumber(char)
{ return p_digits.indexOf(char) >= 0 ;
};


function setToken(curtype,curvalue,curlength)
{ p_tokenType=curtype;
  p_tokenvalue=curvalue;
  p_tokenLength=curlength;
};


function nextToken(inputstring,pos)
{   var char, t, inilen, cpos, cstring;
	cstring=inputstring;
	cpos=pos;
	inilen=inputstring.length;

	if(cpos >= inilen || cpos<0) return false;
	char=cstring.charAt(cpos);

	if(isLetter(char))
		{ t=char;
          do
		    { cpos+=1;
              if(cpos >= inilen) break;
              char = cstring.charAt(cpos);
              if(!isLetter(char)) break;
              t+=char;
            }
		  while(1);

		       if(isTokenF1(t))   { setToken("f1", t, t.length); return true; }
		  else if(isTokenF2(t))   { setToken("f2" ,t, t.length); return true; }
	      else                    { setToken("variable",  t ,t.length); return true; }
	    }

	if(isNumber(char))
	    {  t=char;
		    do
			  { cpos+=1;
                if(cpos >= inilen) break;
                char=cstring.charAt(cpos);
                if(!isNumber(char)) break;
                t+=char;
              }
			while(1);
            setToken("num",t,t.length);
			return true;

		}

	if(isOperator(char))
	   {  setToken("oper",char,1);
	      return true;
	   }

	return false;
};



function checkToks(inputstring) {

	var pstring, pinilen, ppos, fpos, bpos, fchar,
	bchar, counter, matchpar, iscomma, comcounter;

	pstring=inputstring;
	ppos = 0;
	counter = 0;
	comcounter = 0;
	pinilen = pstring.length;

	if(pstring.indexOf("---") >= 0)
		{ setError("Too many minuses.");
		  return;
		}

	while(ppos < pinilen && counter<pinilen*2)
		{ if(nextToken(pstring , ppos))
            { fpos=ppos+p_tokenLength;
			  fchar=pstring.charAt(fpos);
			  bpos=(ppos-1);
			  bchar=pstring.charAt(bpos);


	          if(p_tokenType=="f1")
			  	{ if(!(fchar=="("))
					{ setError("'(' expected at position " + fpos +"."); return; }

				  if(ppos > 0 && !(isOperator(bchar)))
					{ setError("Operator expected at position " + bpos +"."); return; }

				  if(ppos > 0 && bchar==")")
					{ setError("Operator expected at position " + bpos +"."); return; }
				}


		     if(p_tokenType=="f2")
			 	{ if(!(p_tokenvalue=="max") && !(p_tokenvalue=="min")&& !(p_tokenvalue=="pow"))
					{ setError("Unknown functions at position " + fpos +"."); return; }

			      if(!(fchar=="("))
				  	{ setError("'(' expected at position " + fpos +"."); return; }
				  else
				    { matchpar=1; iscomma=0; comcounter=0;
					  while(matchpar>0 && comcounter<pinilen)
					  	{ comcounter++;
					      if(pstring.charAt(fpos+comcounter)=="("){matchpar+=1;}
                          if(pstring.charAt(fpos+comcounter)==")"){matchpar+=-1;}
					      if(pstring.charAt(fpos+comcounter)==","){iscomma+=1;}
						}

					  if(iscomma==0)
						{ setError("Two arguments expected for function at position " + ppos +"."); return; }
					}

				 if(ppos > 0 && !(isOperator(bchar)))
					{ setError("Operator expected at position " + bpos +"."); return; }

				 if(ppos > 0 && bchar==")")
					{ setError("Operator expected at position " + bpos +"."); return; }
				}


		   if(p_tokenType=="variable")  //variable
		      { if(!(isVariable(p_tokenvalue) || p_tokenvalue=="pi" || p_tokenvalue=="e"))
				  { setError("Unknown entries at position " + ppos +"."); return; }

			   if(ppos > 0 && !(isOperator(bchar)))
			   	  { setError("Operator expected at position " + bpos +".");return; }

			   if(ppos > 0 && bchar==")")
			   	  { setError("Operator expected at position " + bpos +".");return; }

			   if(fpos < pinilen && !(isOperator(fchar)))
			   	  { setError("Operator expected at position " + fpos +"."); return; }

			   if(fpos < pinilen && fchar=="(")
			   	 { setError("Operator expected at position " + fpos +"."); return; }
			  }


		   if(p_tokenType=="num")  //number
		   	 { if(ppos > 0 && !(isOperator(bchar)))
			 	  { setError("Operator expected at position " + bpos +".");return; }

			   if(ppos > 0 && bchar==")")
				 { setError("Operator expected at position " + bpos +"."); return; }

			   if(fpos < pinilen && !(isOperator(fchar)))
			     { setError("Operator expected at position " + fpos +"."); return; }

			   if(fpos < pinilen && fchar=="(")
			   	  {  setError("Operator expected at position " + fpos +".");return; }
			 }


		   if(p_tokenvalue=="(")
		   	 { if(fpos < pinilen && ("^*,)+/").indexOf(fchar)>=0)
			     { setError("Entries expected at position " + fpos +"."); return; }
			 }


	       if(p_tokenvalue==")")
		     { if(fpos < pinilen && ("^*+-,/)").indexOf(fchar)==-1)
			     { setError("Entries expected at position " + fpos +"."); return; }

			   if(bpos >=0 && ("^*+-,/(").indexOf(bchar)>=0)
			     { setError("Entries expected at position" + fpos +"."); return; }
			 }


		   if(p_tokenvalue==",")
		   	 {  if(ppos==0 || ppos==pinilen-1)
			 	  { setError("Stray comma at position " + ppos +".");  return; }

				if(fpos < pinilen && ("^*+,/)").indexOf(fchar)>=0)
				  { setError("Entries expected at position " + fpos +".");  return; }

				if(bpos >=0 && ("^*+-,/(").indexOf(bchar)>=0)
				  { setError("Entries expected at position " + fpos +".");  return; }
			 }


		   if(("^/*-+").indexOf(p_tokenvalue)>=0)
		     {  if(("+*^/),").indexOf(fchar)>=0)
			 	  { setError("Entries expected at position " + fpos +"."); return; }

			    if(("+*^/(,").indexOf(bchar)>=0 && !(p_tokenvalue=="-"))
				  { setError("Entries expected at position " + fpos +"."); return; }
			 }


            }
	     else
		    { setError("Unknown characters at position ." + ppos);}
		      ppos+=p_tokenLength;
	          counter+=1;
		    }
};




function conOper(inputstring, char)
// Convert operator in inputString (+ - * /) into function calls
{ var transtring, inilen, mco, curpos, leftoper, rightoper,leftmove,rightmove;

  inilen=inputstring.length;
  transtring=inputstring;

  if(transtring.indexOf(char)==-1)  //this operator not present
      return transtring;

  if(transtring.indexOf(char)==0 && !(char=="-"))  //illegal operator in first char
    { setError("Error at the first " + char);
      return "";
	}

  if(transtring.charAt(transtring.length-1)==char)  //illegal operator in last posn
    { setError("Error at the last " + char + ".");
      return "";
	}

   mco=0;
   while(transtring.indexOf(char)>0 && mco<inilen*6)
   		{  mco++;
           curpos=transtring.indexOf(char);
           leftmove=goLeft(transtring,curpos);
           if(p_iserror==1)
		   		{ setError("Error at  " + char + "  number " + mco + ".");
                  return "";
				}

		   leftoper=transtring.substring(leftmove+1,curpos);
           rightmove=goRight(transtring,curpos);
           if(p_iserror==1)
		   		{  setError("Error at  " + char + "  number " + mco + ".");
                   return "";
				}

		   rightoper = transtring.substring(curpos+1, rightmove);

		   if(char=="*")   //multiply
		   		{  transtring = transtring.substring(0,leftmove+1)
	                          + "mul("+ leftoper+ "," + rightoper + ")"
							  + transtring.substring(rightmove,transtring.length+1);
		        }

		   if(char=="/")  //divide
		   		{  transtring = transtring.substring(0,leftmove+1)
	                          + "div("+ leftoper+ "," + rightoper + ")"
				              + transtring.substring(rightmove,transtring.length+1);
		        }

		   if(char=="-")  //subtract
		   		{  transtring = transtring.substring(0,leftmove+1)
	                          + "minus("+ leftoper + "," + rightoper + ")"
							  + transtring.substring(rightmove,transtring.length+1);
		        }

		   if(char=="+")  //add
		   		{ transtring = transtring.substring(0,leftmove+1)
	                         + "plus("+ leftoper + "," + rightoper + ")"
							 + transtring.substring(rightmove,transtring.length+1);
		        }
		} //while
	return transtring;
};



function conUnary(inputstring)
// Converts any unary minus to minus(0,x)
{  var transtring, inilen, mco, curpos,  j;
   inilen=inputstring.length;
   transtring=inputstring;

   if(transtring.indexOf("-")==-1) //no subtract operators at all
      { return transtring;
	  }

   if(transtring.charAt(transtring.length-1)=="-")  //illegal trailing minus
      {  setError("Error at the last minus.");
        return "";
	  }

   for(var i=0; i<transtring.length; i++)
      { if(transtring.charAt(i)=="-" && unaryId(transtring.charAt(i-1)))
	      {  j=goRight(transtring, i);
		     if(p_iserror==1)
			   { setError("Error at position " + i);
		         return "";
			   }
		     transtring = transtring.substring(0,i)
			           + "minus(0,"+transtring.substring(i+1,j) + ")"
					   + transtring.substring(j,transtring.length);
		  }
	  }
  return transtring;
};


function unaryId(char)
{  return ("+-,(/*^".indexOf(char)>-1)
};


function goRight(inputstring, pos)
{ var rightchar, rightcounter, matchpar;

  rightchar = inputstring.charAt(pos+1);
  rightcounter = pos+1;
  if(rightchar=="-")
  		{ rightcounter++;
	      if(rightcounter>=inputstring.length)
		  	{ p_iserror=1;
              return rightcounter;
			}
		  else
		    {  rightchar=inputstring.charAt(rightcounter);
			}
		}

  if(p_digits.indexOf(rightchar)>-1)
  		{ while(p_digits.indexOf(inputstring.charAt(rightcounter))>-1 && rightcounter<inputstring.length)  rightcounter++;
		}
  else if(p_letters.indexOf(rightchar)>-1)
  		{ while(p_letters.indexOf(inputstring.charAt(rightcounter))>-1  && rightcounter<inputstring.length) rightcounter++;
	      if(inputstring.charAt(rightcounter)=="(")
		  		{  matchpar = 1;
		           while(matchpar>0 && rightcounter<inputstring.length)
		   				{ rightcounter+=1;
			              if(inputstring.charAt(rightcounter)=="(") matchpar++;
                          if(inputstring.charAt(rightcounter)==")"){matchpar--;}
						}
				}

	      if(matchpar>0)
				{ p_iserror=1;
				  return rightcounter;
				}
		}
  else if(rightchar=="(")
  		{  matchpar = 1;
           while(matchpar>0 && rightcounter<inputstring.length)
		  	 { rightcounter++;
		       if(inputstring.charAt(rightcounter)=="(") matchpar++;
		       if(inputstring.charAt(rightcounter)==")") matchpar--;
		     }
		   rightcounter++;
		   if(matchpar>0)
		      { p_iserror=1;
                return rightcounter;}
		      }

  else { p_iserror=1;
         return rightcounter;
	   }

  return rightcounter;
};


function goLeft(inputstring, pos)
{ var leftchar, leftcounter, matchpar;

  leftchar=inputstring.charAt(pos-1);
  leftcounter=pos-1;

  if(p_digits.indexOf(leftchar)>-1)
  	 while(p_digits.indexOf(inputstring.charAt(leftcounter))>-1 && leftcounter>=0) leftcounter--;

  else if(p_letters.indexOf(leftchar)>-1)
     while(p_letters.indexOf(inputstring.charAt(leftcounter))>-1 && leftcounter>=0) leftcounter--;

  else if(leftchar==")")
  	{ matchpar = 1;
      if(leftcounter==0)
	  	{ p_iserror=1;
          return leftcounter;
		}

      while(matchpar>0 && leftcounter>0)
	    { leftcounter+=-1;
          if(inputstring.charAt(leftcounter)==")") matchpar++;
          if(inputstring.charAt(leftcounter)=="("){matchpar--;}
	    }

	  leftcounter+=-1;
	  if(matchpar>0)
	  	{ p_iserror=1;
          return leftcounter;
	    }

      if(leftcounter>=0 && p_digits.indexOf(inputstring.charAt(leftcounter))>-1)
	    { p_iserror=1;
          return leftcounter;
		}

      if(leftcounter==0 && !(inputstring.charAt(leftcounter)=="-")&& !(inputstring.charAt(leftcounter)=="("))
	  	{ p_iserror=1;
          return leftcounter;
		}

     if(leftcounter>0 && p_letters.indexOf(inputstring.charAt(leftcounter))>-1)
	 	while(p_letters.indexOf(inputstring.charAt(leftcounter))>-1 && leftcounter>=0)	leftcounter--;
	}
  else
    { p_iserror=1;
      return leftcounter;
    }

  return leftcounter;
};



function conCaret(inputstring)
// Converts any carets to calls to pow().
{ var transtring, inilen, mco, curpos, leftmove, rightmove, base, expon;

  inilen=inputstring.length;
  transtring=inputstring;

  if(transtring.indexOf("^")==-1)         //no carets
  	  return transtring;

  if(transtring.indexOf("^")==0)          //1st char cannot be a caret
	{ setError("Error at the first ^.");
      return "";
	}

  if(transtring.charAt(transtring.length-1)=="^") //last char cannot be caret
  	{ setError("Error at the last ^.");
	 return "";
	}

  mco=0;
  while(transtring.indexOf("^")>0 && mco<inilen*6)
    { mco++;
      curpos=transtring.lastIndexOf("^");
	  leftmove=goLeft(transtring,curpos);
	  if(p_iserror==1)
	  	 { setError("Error at ^ number " + mco + " from the end.");
		   return "";
		 }

	  base=transtring.substring(leftmove+1,curpos);
	  rightmove=goRight(transtring,curpos);
	  if(p_iserror==1)
	  	{ setError("Error at ^ number " + mco + " from the end.");
          return "";
		}

	  expon = transtring.substring(curpos+1, rightmove);
	  transtring = transtring.substring(0,leftmove+1)
	             + "pow("+ base+ "," + expon + ")"
				 + transtring.substring(rightmove,transtring.length+1);
	}
  return transtring;
};



function errorObject(messg,  errStatus)
// Makes and returns a compiledObject set to an error state
{   var retObj=new CompiledObject();
	with(retObj)
		{ polishArray=[];
	      errorMes=messg;
          errorStatus=errStatus;
		}
	return retObj;
};


function whiteSpaces(inputstring)
//  Returns input with spaces removed
{  var curpos, transtring, inilen, counter=0;
   inilen=inputstring.length;
   transtring=inputstring.toLowerCase();
   while(transtring.indexOf(" ")>-1 && counter < inilen+1)
     {  curpos=transtring.indexOf(" ");
	    transtring=transtring.substring(0,curpos) +
	    transtring.substring(curpos+1,transtring.length);
	    counter+=1;
     }
   return transtring;
};



function checkLegal(inputstring)
// verifies that each char is either a letter, number or operator
{  var legal, curchar;

   for(var i=0; i<inputstring.length; i++)
		{ curchar=inputstring.charAt(i);
	      legal=p_digits.indexOf(curchar)+p_letters.indexOf(curchar)+p_operators.indexOf(curchar);
          if(legal==-3)
		    { setError("Unknown characters in expression.");
	          return false;
			}
		}
   return true;
};


function checkPars(inputstring)
{ var i, j, matchpar, left=0, right=0, counter=0;

  for(i=0; i<inputstring.length; i++)
  	 { if(inputstring.charAt(i)=="(") left++;
	   if(inputstring.charAt(i)==")") right++;
	 }

   if(!(left==right))
     { setError("Mismatched parentheses");
	   return false;
	 }

   for(j=0; j<inputstring.length; j++)
      { if(inputstring.charAt(j)=="(")
	      { matchpar=1; counter=0;
		    while(matchpar>0 && counter<inputstring.length)
		       {  counter++;
			      if(inputstring.charAt(j+counter)=="(") matchpar++;
				  if(inputstring.charAt(j+counter)==")") matchpar--;
			   }

		    if(matchpar>0)
				{ j++;
		          setError("Mismatched parenthesis at position number " + j);
			      return false;
				}
		  }
		}

   for(j=0; j<inputstring.length; j++)
		{ if(inputstring.charAt(j)==")")
			{ matchpar=1; counter=0;
			  while(matchpar>0 && counter<inputstring.length)
				{  counter++;
				   if(inputstring.charAt(j-counter)==")") matchpar++;
				   if(inputstring.charAt(j-counter)=="(") matchpar--;
				}
			  if(matchpar>0)
				{ j++;
				  setError("Mismatched parenthesis at position number " + j);
				  return false;
				}
			}
		}
   return true;
};



function makeStack(inputstring)
{ var mstring, minilen, mpos, mstack, checkStack,
  checkExpr, counter;

  mstring=inputstring;
  mpos=0;
  mstack=[];
  checkStack=[];
  minilen=mstring.length;
  checkExpr=[];
  counter=0;

  while(mpos < minilen && counter<minilen*2)
  	{ if(nextToken(mstring,mpos))
		{
		  if(p_tokenType=="f1")
			{ mstack.push(this[p_tokenvalue]);
			  mstack.push("f1");
			  checkStack.push(this["sin"]);
	          checkStack.push("f1");
		    }

		 if(p_tokenType=="f2")
		 	{ mstack.push(this[p_tokenvalue]);
			  mstack.push("f2");
			  checkStack.push(this["plus"]);
			  checkStack.push("f2");
		    }

		 if(p_tokenType=="variable")
		 	{ mstack.push(p_tokenvalue);
			  mstack.push("variable");
			  checkStack.push("x");
			  checkStack.push("variable");
		    }

		  if(p_tokenType=="num")
		  	{ mstack.push(Number(p_tokenvalue));
			  mstack.push("num");
			  checkStack.push(Number(p_tokenvalue));
			  checkStack.push("num");
		   }
		}
	  else
	    { setError("Unknown characters.");
		  return [];
		}

	  mpos+=p_tokenLength;
	  counter++;
	}

  mstack.reverse();
  checkExpr=checkStack.reverse();
  checkEval(checkExpr);
  if(p_iserror==1) return [];
  return(mstack);
};


function setError(mess)  //set up an error
{ p_errorMes="Syntax error: " + mess;
  p_iserror = 1;
};


function checkEval(compiledExpression)
{ var entrytype="";
  var operands=[];
  var arg1, arg2;

  for( var i=0; i<compiledExpression.length; i++)
  	{ entrytype = compiledExpression[i++];

      if(entrytype == "num")
	  	{ operands.push(compiledExpression[i]);
		}
	  else if( entrytype == "variable")
	  	{ operands.push(1);
		}
	  else if( entrytype == "f1")
	    {  if(operands.length<1) { setError("Check number of arguments in functions."); return;}
		   operands.push(compiledExpression[i](operands.pop()))
		}
	  else if( entrytype == "f2")
	  	{ if(operands.length<2){ setError("Check number of arguments in functions."); return;}
          arg1=operands.pop();
		  arg2=operands.pop();
		  operands.push(compiledExpression[i](arg1,arg2));
		}
	  else
	  	{ setError("Can't evaluate."); return;
		}
	}

  if(!(operands.length==1))
  	{ setError("");
      return;
    }

  if(isNaN(operands[0]))
	{ setError("");
      return;
    }
};


function sin(a)		{return Math.sin(a);};
function cos(a)		{return Math.cos(a);};
function tan(a)		{return Math.tan(a);};
function ln(a)		{return Math.log(a);};
function log(a)		{return Math.log(a)/Math.log(10);};
function sqrt(a)	{return Math.sqrt(a);};
function exp(a)		{return Math.exp(a);};
function abs(a)		{return Math.abs(a);};
function asin(a)	{return Math.asin(a);};
function acos(a)	{return Math.acos(a);};
function atan(a)	{return Math.atan(a);};
function sec(a)		{return 1/Math.cos(a);};
function csc(a)		{return 1/Math.sin(a);};
function cot(a)		{return 1/Math.tan(a);};
function floor(a)	{return Math.floor(a);};
function ceil(a)	{return Math.ceil(a);};
function round(a)	{return Math.round(a);};
function max(a,b)	{return Math.max(a,b);};
function min(a,b)   {return Math.min(a,b);};
function plus(a,b)  {return a + b;};
function minus(a,b) {return a - b;};
function mul(a,b)	{return a * b;};
function div(a,b)	{return a / b;  };
function  pow(a, b)
  { if (a<0 && b==Math.floor(b))
      { if((b % 2)==0)
	      return Math.pow(-a, b);
        else
		  return -Math.pow (-a, b);
	  }
   if (a==0 && b>0)      return 0;
   if(isNaN(a) && b==0)  return NaN;
   return Math.pow (a, b);

  };



function doEval(compiledObject, aVarVals)
 {
	var entrytype = "";
	var operands = [];
    var compiledExp = compiledObject.polishArray;
    var numItems = compiledExp.length;

	var arg0;
	var arg1;
	var arg2;
	var item;
	for(var i = 0; i < numItems; i++)
	  {
	    entrytype = compiledExp[i++];
		item = compiledExp[i];

		if(entrytype == "num")
		  { operands.push(item);
		  }

		else if( entrytype == "variable")
		  { if(item=="e")
		      { operands.push(Math.E);
			  }
			else if(item=="pi")
			  { operands.push(Math.PI);
			  }
		    else
			  { for(var k=0; k < p_varNames.length; k++) //find var in list
			       { if(item==p_varNames[k])
				       { operands.push(aVarVals[k]);
					     break;
			           }
		           }
	          }
		  }

		else if( entrytype == "f1")  //functions with a single argument
		  { arg0 = operands.pop();

		       if(item==sin)  { operands.push(Math.sin(arg0));  }
		  else if(item==cos)  { operands.push(Math.cos(arg0));  }
		  else if(item==tan)  { operands.push(Math.tan(arg0));  }
          else if(item==asin) { operands.push(Math.asin(arg0)); }
		  else if(item==acos) { operands.push(Math.acos(arg0)); }
          else if(item==atan) { operands.push(Math.atan(arg0)); }
		  else if(item==ln  ) { operands.push(Math.log(arg0));  }
		  else if(item==sqrt) { operands.push(Math.sqrt(arg0)); }
		  else if(item==exp)  { operands.push(Math.exp(arg0));  }
          else if(item==abs)  { operands.push(Math.abs(arg0));  }
          else if(item==ceil) { operands.push(Math.ceil(arg0)); }
          else if(item==floor){ operands.push(Math.floor(arg0));}
          else if(item==round){ operands.push(Math.round(arg0));}
          else                { operands.push(item(arg0));      }
		 }

		else if(entrytype == "f2")  //functions with two arguments
		  { arg1=operands.pop();
			arg2=operands.pop();

			     if(item==mul)  { operands.push(arg1*arg2); }
			else if(item==plus) { operands.push(arg1+arg2); }
			else if(item==minus){ operands.push(arg1-arg2); }
			else if(item==div)  { operands.push(arg1/arg2); }
			else if(item==pow)  { operands.push(Math.pow(arg1,arg2));}
			else if(item==min)  { operands.push(Math.min(arg1,arg2));}
			else if(item==max)  { operands.push(Math.max(arg1,arg2));}
			else                { operands.push(item(arg1,arg2));	 }

		  }
		else
		  { return NaN;
          }
	  }
	return operands[0]
};



function CompiledObject()
// Holds the compiled expression.  Can also hold an error state.
// The function doCompile() instantiates them with a 'new' call and hands them back to the caller for saving.
// Then they can be passed to doEval() for execution.
{   this.polishArray = [];  //the compiled code itself
	this.errorMes   = "";
	this.errorStatus = 0;
};












function Plotter(wid, ht)  //Constructor
	{   this.type = "Plotter";
        this.wid = wid;
	    this.ht  = ht;

		this.wid;               //width of plot window in px
		this.ht;                //height of plot window in px
		this.xMin;              //lower x value limit in math units
		this.xMax;              //upper x value limit in math units
		this.yMin;              //lower y value limit in math units
		this.yMax;              //upper y value limit in math units
		this.lineWid  = 1;
		this.lineCol    = 0x000000;
		this.lineAlph = 1;
		this.shadeColor = 0x00ff00;  //green
		this.shadeAlpha      = 0.2;
		this.visibleLine = true;

		this.dashed = false;
		this.topShade = false;
		this.bottomShade = false;
		this.prevX;
		this.prevY;

		this.dashCtr;
        this.dashLen = 7;
        this.spaceLen = 1;
		this.inDash = true;

        this.can;  //canvas element
        this.context;

    //make a canvas element for the output.
    //This floats over the main applet so only this part needs to be redrawn as the sliders move.
    this.can = document.createElement('canvas');
	with( this.can)
		{
           with(style)
	         { position = "absolute";
               top =  (graphTop*bScale)+"px";
               left = (graphLeft*bScale)+"px";
            }
          width = graphWidth*bScale;
		  height = graphHeight*bScale;
		}

    //attach it to host window
	document.body.appendChild(this.can);
    this.context = this.can.getContext('2d');
    this.context.scale(bScale, bScale);



    //make another canvas element for the dashed lines.
    //This floats over the graph canvas so we can plot the dashed line at the same time as the main graph
    this.dashCan = document.createElement('canvas');
	with( this.dashCan)
		{  with(style)
	         { position = "absolute";
               top =  (graphTop*bScale)+"px";
               left = (graphLeft*bScale)+"px";
            }
           width = graphWidth*bScale;
		   height = graphHeight*bScale;
		}

    //attach it to host window
	document.body.appendChild(this.dashCan);
    this.dashCtx = this.dashCan.getContext('2d');
    this.dashCtx.scale(bScale, bScale);



    this.clear = function()
    {  this.context.clearRect(0, 0, graphWidth, graphHeight);
       this.dashCtx.clearRect(0, 0, graphWidth, graphHeight);
       this.dashed = false;
	   this.topShade = false;
	   this.bottomShade = false;
    };


	this.init = function(xMin, xMax, yMin, yMax)
	{ this.xMin = xMin;
	  this.xMax = xMax;
	  this.yMin = yMin;
	  this.yMax = yMax;
      this.clear();
	};

	this.setVisible = function(val)
	{ this.visibleLine = val;
	};

	this.setDashed = function(val)
	{ this.dashed = val;
	};

	this.setTopShading = function()
	{ this.topShade = true;
	  this.bottomShade = false;
	};

	this.setBottomShading = function()
	{ this.topShade = false;
	  this.bottomShade = true;
	};



	this.beginPlot = function(lineWid, lineCol, lineAlph, shadeColor)
	{
      this.lineWid = lineWid;
	  this.lineCol = lineCol;
	  this.lineAlph = lineAlph;
	  this.prevX = this.prevY = 0;
	  if (this.topShade || this.bottomShade)
	     { this.context.fillStyle = toStr(shadeColor, this.shadeAlpha);
		 }
      this.context.beginPath();
      this.context.lineWidth = this.lineWid;

      this.dashCtx.beginPath();
      this.dashCtx.lineWidth = this.lineWid;
      this.dashCtx.strokeStyle = toStr(this.lineCol, this.lineAlpha);
      this.dashLen = 4;
      this.spaceLen = 2;
      this.dashCtr = this.dashLen;
      this.inDash = true;
    };


	this.plotPoint = function(xPix ,mathy)
	{
	  //convert to pixels
	  var yPix = this.ht*(this.yMax - mathy)/(this.yMax- this.yMin) ;

	  if(this.visibleLine)  //some points are not plotted because they are NaN
		  this.context.strokeStyle=toStr(this.lineCol, this.lineAlph);
	  else
		  this.context.strokeStyle=toStr(this.lineCol, 0);    //invis line by using alpha=0

	  this.context.lineTo(xPix,yPix);
	  this.prevX=xPix;  this.prevY=yPix;

      // If dashed is set, the main plot will not stroke() so it will not draw a line, just the fill.
      // On another canvas we draw the dashed line.
      if(this.dashed)
		{ this.dashCtr--;
		  if(this.inDash)
			{ this.dashCtx.lineTo(xPix,yPix);
              if(this.dashCtr <= 0) // end of a dash
			    { this.dashCtr = this.spaceLen;
			      this.inDash = false;
                  this.dashCtx.stroke();
                }
			}
		  else
			{ if(this.dashCtr <= 0) // end of a dash
			    { this.dashCtx.beginPath();
			      this.dashCtr = this.dashLen;
			      this.inDash = true;
                }
			}
		}
	}; //fn


	this.endPlot = function()
	{
      if(this.dashed)
         this.dashCtx.stroke();
      else
         this.context.stroke(); // draw the line

	  // If the graph is an inequality, we close the shape by drawing into the
	  // chart box corners and let endFill() close it back to the first point plotted

	  if(this.topShade)  //close top of curve
		with(this.context)
			{ this.context.strokeStyle=toStr(this.lineCol, 0);    //invis line by using alpha=0
			  lineTo(wid, 0);
			  lineTo(0,0);
			  fill();
			}

	  if(this.bottomShade)  //close bottom of curve
		with(this.context)
			{ this.context.strokeStyle=toStr(this.lineCol, 0);    //invis line by using alpha=0
			  lineTo(this.wid, this.ht);
			  lineTo(0 ,this.ht);
			  fill();
			}


	  this.topShade = this.bottomShade = false;
	  this.visibleLine = true;
	};




} ;//class
